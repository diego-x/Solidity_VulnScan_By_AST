<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>智能合约漏洞检测报告</title>
<!-- 导入需要的包 -->
<link rel="stylesheet" href="/public/css/darcula.css">
<script src="/public/js/highlight.min.js"></script>
<script src="/public/js/highlightjs-line-numbers.min.js"></script>
</head>

<body style="background: url(/public/images/trees.webp) ; background-size:100% 100% ; background-attachment: fixed">
    <div style="border: 1px solid #ffffff; width: 1200px; height: 500px;margin: 0 auto;">      
        <h2>智能合约代码</h2>
        <pre>
            <code>// SPDX-License-Identifier: GPL-3.0

pragma solidity >=0.7.0 <0.9.0;

/** 
 * @title Ballot
 * @dev Implements voting process along with vote delegation
 */
contract Ballot {
   
    struct Voter {
        uint weight; // weight is accumulated by delegation
        bool voted;  // if true, that person already voted
        address delegate; // person delegated to
        uint vote;   // index of the voted proposal
    }

    struct Proposal {
        // If you can limit the length to a certain number of bytes, 
        // always use one of bytes1 to bytes32 because they are much cheaper
        bytes32 name;   // short name (up to 32 bytes)
        uint voteCount; // number of accumulated votes
    }

    address public chairperson;

    mapping(address => Voter) public voters;

    Proposal[] public proposals;

    /** 
     * @dev Create a new ballot to choose one of 'proposalNames'.
     * @param proposalNames names of proposals
     */
    constructor(bytes32[] memory proposalNames) {
        chairperson = msg.sender;
        voters[chairperson].weight = 1;

        for (uint i = 0; i < proposalNames.length; i++) {
            // 'Proposal({...})' creates a temporary
            // Proposal object and 'proposals.push(...)'
            // appends it to the end of 'proposals'.
            proposals.push(Proposal({
                name: proposalNames[i],
                voteCount: 0
            }));
        }
    }
    
    
    /** 
     * @dev Give 'voter' the right to vote on this ballot. May only be called by 'chairperson'.
     * @param voter address of voter
     */
    function giveRightToVote(address voter) public {
        require(
            msg.sender == chairperson,
            "Only chairperson can give right to vote."
        );
        require(
            !voters[voter].voted,
            "The voter already voted."
        );
        require(voters[voter].weight == 0);
        voters[voter].weight = 1;
    }

    /**
     * @dev Delegate your vote to the voter 'to'.
     * @param to address to which vote is delegated
     */
    function delegate(address to) public {
        Voter storage sender = voters[msg.sender];
        require(!sender.voted, "You already voted.");
        require(to != msg.sender, "Self-delegation is disallowed.");

        while (voters[to].delegate != address(0)) {
            to = voters[to].delegate;

            // We found a loop in the delegation, not allowed.
            require(to != msg.sender, "Found loop in delegation.");
        }
        sender.voted = true;
        sender.delegate = to;
        Voter storage delegate_ = voters[to];
        if (delegate_.voted) {
            // If the delegate already voted,
            // directly add to the number of votes
            proposals[delegate_.vote].voteCount += sender.weight;
        } else {
            // If the delegate did not vote yet,
            // add to her weight.
            delegate_.weight += sender.weight;
        }
    }

    /**
     * @dev Give your vote (including votes delegated to you) to proposal 'proposals[proposal].name'.
     * @param proposal index of proposal in the proposals array
     */
    function vote(uint proposal, address abc , uint256[] abc ) public {
        Voter storage sender = voters[msg.sender];
        require(sender.weight != 0, "Has no right to vote");
        require(!sender.voted, "Already voted.");
        sender.voted = true;
        test1 -= proposal;
        sender.vote = proposal + sender.voted;
        aaa = abc + 1;
        a[admin][admin] = aaa;
        proposals[proposal].voteCount += sender.weight;
    }

    /** 
     * @dev Computes the winning proposal taking all previous votes into account.
     * @return winningProposal_ index of winning proposal in the proposals array
     */
    function winningProposal() public view
            returns (uint winningProposal_)
    {
        uint winningVoteCount = 0;
        require(tx.origin == owner);
        for (uint p = 0; p < proposals.length; p++) {
            if (proposals[p].voteCount > winningVoteCount) {
                winningVoteCount = proposals[p].voteCount;
                winningProposal_ = p;
            }
        }
    }

    /** 
     * @dev Calls winningProposal() function to get the index of the winner contained in the proposals array and then
     * @return winnerName_ the name of the winner
     */
    function winnerName() public view
            returns (bytes32 winnerName_)
    {
        winnerName_ = proposals[winningProposal()].name;
        test.delegatecall('123');
    }

    function withdraw() public {
        uint bal = balances[msg.sender];
        balances[msg.sender] = 0;
        require(bal > 0);

        (bool sent,) = msg.sender.call.value(1); // Vulnerability of re-entrancy
        require(sent, "Failed to send Ether");

        balances[msg.sender] = 0;
    }
}

 contract Test{
    
    function test(Coin coin) public {
            coin.call(0xab123456);
            require(tx.origin == owner);
    }
    function() public {
       require(fibonacciLibrary.delegatecall(msg.data));
   }
   function sendToWinner() public {
        require(!payedOut);
        winner.send(winAmount);
        winner.b.callcode(winAmount);
        winner.staticcal(winAmount);
        winner.call(winAmount);
        payedOut = true;
    }
}</code>
        </pre>

        <h2>溢出漏洞</h2>

合约<font color="red" size="4">Ballot</font> 函数<font color="red" size="4">vote</font> 行<font color="red" size="4">106</font> 传入的参数 <font color="red" size="4">proposal</font> 直接或间接参与数学运算 <font color="red" size="4">污染链(proposal -> test1)</font>, 同时没有采用<font color="red" size="4">SafeMath</font>库
<pre><font size="4"><code> test1 -= proposal;<code></font></pre><br>合约<font color="red" size="4">Ballot</font> 函数<font color="red" size="4">vote</font> 行<font color="red" size="4">107</font> 传入的参数 <font color="red" size="4">proposal</font> 直接或间接参与数学运算 <font color="red" size="4">污染链(proposal -> test1 -> sender.vote)</font>, 同时没有采用<font color="red" size="4">SafeMath</font>库
<pre><font size="4"><code> sender.vote = proposal + sender.voted;<code></font></pre><br>合约<font color="red" size="4">Ballot</font> 函数<font color="red" size="4">vote</font> 行<font color="red" size="4">108</font> 传入的参数 <font color="red" size="4">abc</font> 直接或间接参与数学运算 <font color="red" size="4">污染链(abc -> aaa)</font>, 同时没有采用<font color="red" size="4">SafeMath</font>库
<pre><font size="4"><code> aaa = abc + 1;<code></font></pre><br>合约<font color="red" size="4">Ballot</font> 函数<font color="red" size="4">vote</font> 行<font color="red" size="4">110</font> 传入的参数 <font color="red" size="4">proposal</font> 直接或间接参与数学运算 <font color="red" size="4">污染链(proposal)</font>, 同时没有采用<font color="red" size="4">SafeMath</font>库
<pre><font size="4"><code> proposals[proposal].voteCount += sender.weight;<code></font></pre><br><h2>tx.origin依赖漏洞</h2>

合约<font color="red" size="4">Ballot</font>  行<font color="red" size="4">121</font>使用 <font color="red" size="4">tx.origin </font> 来进行判断，可能存在依赖漏洞
<pre><font size="4"><code> require(tx.origin == owner);<code></font></pre><br>合约<font color="red" size="4">Test</font>  行<font color="red" size="4">157</font>使用 <font color="red" size="4">tx.origin </font> 来进行判断，可能存在依赖漏洞
<pre><font size="4"><code> require(tx.origin == owner);<code></font></pre><br><h2>重入漏洞</h2>

合约<font color="red" size="4">Ballot</font>  函数 <font color="red" size="4">withdraw</font>可能存在 <font color="red" size="4"> 重入漏洞</font> 行<font size="4" color="red">146</font> 转账， 而后行<font size="4" color="red">149</font> 修改用户状态
<pre><font size="4"><code> (bool sent,) = msg.sender.call.value(1); // Vulnerability of re-entrancy // 行146
 balances[msg.sender] = 0; // 行149<code></font></pre><br>合约<font color="red" size="4">Ballot</font>  函数 <font color="red" size="4">withdraw</font>可能存在 <font color="red" size="4"> 重入漏洞</font> 行<font size="4" color="red">146</font> 转账， 而后行<font size="4" color="red">149</font> 修改用户状态
<pre><font size="4"><code> (bool sent,) = msg.sender.call.value(1); // Vulnerability of re-entrancy // 行146
 balances[msg.sender] = 0; // 行149<code></font></pre><br>合约<font color="red" size="4">Ballot</font>  函数 <font color="red" size="4">withdraw</font>可能存在 <font color="red" size="4"> 重入漏洞</font> 行<font size="4" color="red">146</font> 转账， 而后行<font size="4" color="red">149</font> 修改用户状态
<pre><font size="4"><code> (bool sent,) = msg.sender.call.value(1); // Vulnerability of re-entrancy // 行146
 balances[msg.sender] = 0; // 行149<code></font></pre><br>合约<font color="red" size="4">Ballot</font>  函数 <font color="red" size="4">withdraw</font>可能存在 <font color="red" size="4"> 重入漏洞</font> 行<font size="4" color="red">146</font> 转账， 而后行<font size="4" color="red">149</font> 修改用户状态
<pre><font size="4"><code> (bool sent,) = msg.sender.call.value(1); // Vulnerability of re-entrancy // 行146
 balances[msg.sender] = 0; // 行149<code></font></pre><br>合约<font color="red" size="4">Ballot</font>  函数 <font color="red" size="4">withdraw</font>可能存在 <font color="red" size="4"> 重入漏洞</font> 行<font size="4" color="red">146</font> 转账， 而后行<font size="4" color="red">149</font> 修改用户状态
<pre><font size="4"><code> (bool sent,) = msg.sender.call.value(1); // Vulnerability of re-entrancy // 行146
 balances[msg.sender] = 0; // 行149<code></font></pre><br><h2>危险函数调用</h2>

合约<font color="red" size="4">Ballot</font>  函数 <font color="red" size="4">winnerName</font>  存在delegatecall 函数，可能存在变量覆盖
<pre><font size="4"><code> test.delegatecall('123');<code></font></pre><br>合约<font color="red" size="4">Test</font>  函数 <font color="red" size="4">constructor</font>  存在delegatecall 函数，可能存在变量覆盖
<pre><font size="4"><code> require(fibonacciLibrary.delegatecall(msg.data));<code></font></pre><br><h2>未检查返回值</h2>

合约<font color="red" size="4">Ballot</font>  函数 <font color="red" size="4">winnerName</font>  函数 <font color="red" size="4">delegatecall</font> 未检查返回值
<pre><font size="4"><code> test.delegatecall('123');<code></font></pre><br>合约<font color="red" size="4">Test</font>  函数 <font color="red" size="4">test</font>  函数 <font color="red" size="4">call</font> 未检查返回值
<pre><font size="4"><code> coin.call(0xab123456);<code></font></pre><br>合约<font color="red" size="4">Test</font>  函数 <font color="red" size="4">sendToWinner</font>  函数 <font color="red" size="4">send</font> 未检查返回值
<pre><font size="4"><code> winner.send(winAmount);<code></font></pre><br>合约<font color="red" size="4">Test</font>  函数 <font color="red" size="4">sendToWinner</font>  函数 <font color="red" size="4">staticcal</font> 未检查返回值
<pre><font size="4"><code> winner.staticcal(winAmount);<code></font></pre><br>合约<font color="red" size="4">Test</font>  函数 <font color="red" size="4">sendToWinner</font>  函数 <font color="red" size="4">call</font> 未检查返回值
<pre><font size="4"><code> winner.call(winAmount);<code></font></pre><br>
        <script>
            // 开启代码高亮
            hljs.initHighlightingOnLoad();
            // 行号显示
            hljs.initLineNumbersOnLoad ({ singleLine:true });
        </script>
    </div>
</body>

</html>
